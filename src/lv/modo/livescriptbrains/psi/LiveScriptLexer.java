/* The following code was generated by JFlex 1.4.3 on 15.16.10 13:53 */

package lv.modo.livescriptbrains.psi;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.impl.source.tree.ElementType;
import com.intellij.psi.tree.IElementType;

import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Lexer is the first step of the parsing process â€” it creates semantic "tokens" from a piece of plain text.
 * A token represents a context-less, atomic, smallest piece of the programming language,
 * which will later be combined with others into semantic structures by a parser.
 * For example, the letters "i" and "f" one after another (if they are not part of another word, of course)
 * must be converted into an "if" token.
 */
public class LiveScriptLexer implements FlexLexer {

	/**
	 * Character index that the lexer is currently at.
	 */
	private int _currentIndex;

	/**
	 * Index of the first character in the text to process
	 */
	private int _startPosition;

	/**
	 * Length of the input text [fragment].
	 */
	private int _textLength;

	/**
	 * Index of the first character in the last token.
	 */
	private int _tokenStartIndex;

	/**
	 * Index of the next character after the token (i.e., last token character index + 1)
	 */
	private int _tokenEndIndex;

	/**
	 * Are tabs used as indents, instead of spaces?
	 */
	private boolean _indentTab;

	/**
	 * How many tabs/spaces wide is one indent.
	 */
	private int _indentSize;

	/**
	 * Text that we're processing.
	 */
	private CharSequence _text;

	/**
	 * Contains the line of text that is currently being worked on.
	 */
	private CharSequence _line;


	/**
	 * Must always return the position of the first character of whatever the last token returned by {@link #advance()}.
	 * @return
	 */
	@Override
	public int getTokenStart() {
		return this._tokenStartIndex;
	}

	/**
	 * Must always return the index of the last character in the last token returned by {@link #advance()}.
	 * @return
	 */
	@Override
	public int getTokenEnd() {
		return this._tokenEndIndex;
	}

	public LiveScriptLexer() {
		this._line = new StringBuilder();
	}

	/**
	 * Read/process input until a token can be returned, then return it.
	 * <p>This is the main lexer processor method. During the parsing process, this method is called over and over, to get
	 * the tokens one after another. It must return the next token every time, or <tt>null</tt> when the end of file
	 * is reached.</p>
	 * @return
	 * @throws IOException
	 */
	@Override
	public IElementType advance() throws IOException {
		IElementType result = null;

		// We go through the input, one line at a time.
		// Each line is run through the possible token matches.
		// Whenever a token matches, the index of the search is moved beyond it,
		// and the remaining line is run through the possible token matches again.
		// Repeat this until the end of the line is reached or it matches no tokens.
		// If the line matches no tokens and there are still characters left, mark
		// all remaining characters as invalid.

		if (this._currentIndex >= this._textLength)
			return null;

		// Make sure we have a line to work with
		if (this._line == null)
			getLine();

		// Match
		return this._matchLine();
	}

	private Character _getIndentChar() {
		return this._indentTab ? '\t' : ' ';
	}

	/**
	 * Takes the [remaining] line as returned by {@link #getLine()} and tries to
	 * find the first token in it.
	 * @return
	 */
	private IElementType _matchLine() {
		IElementType result;
		Boolean matched = true;
		Matcher matcher;


		// Indent size of 0 means we haven't encountered an indent yet, so whichever -- tab or space --
		// we encounter first will become the tab character, and the number of this character on first
		// encounter will determine the indent size
		String pattern = this._indentSize == 0
				? "^(\\t+| +)"
				: "^" + this._getIndentChar() + "{" + this._indentSize + "}";

		if ((matcher = this._tryMatch(pattern)).find()) {
			if (this._indentSize == 0) {
				this._indentTab = matcher.group(1).startsWith("\t");
				this._indentSize = matcher.group(1).length();
				System.out.println("Indent char is [" + this._getIndentChar() + "] x " + this._indentSize);
			}
			result = LiveScriptTypes.INDENT;
		}
		else {
			matched = false;
			result = ElementType.ERROR_ELEMENT;
		}

		this._tokenStartIndex = this._currentIndex;
		this._tokenEndIndex = this._tokenStartIndex + (matched ? matcher.end() : this._line.length());
		this._currentIndex = this._tokenEndIndex;
		this._line = null;

		return result;
	}

	private Matcher _tryMatch(String patternString) {
		Pattern pattern = Pattern.compile(patternString);
		Matcher matcher = pattern.matcher(this._line);
		return matcher;
	}

	/**
	 * Gets the remaining characters from the current index to the
	 * end of the line and returns it as a single string for matching
	 * against possible tokens.
	 */
	private void getLine() {
		boolean cr = false;
		StringBuilder sb = new StringBuilder();
		for (int a = this._currentIndex; a < this._textLength; a++) {
			char c = this._text.charAt(a);
			if (!cr || c == '\n')
				sb.append(c);

			if (cr || c == '\n' || a == this._textLength - 1) {
				this._line = sb.toString();
				break;
			}

			if (c == '\r') {
				cr = true;
			}
		}
	}


	/**
	 * Commands the lexer to start over from the beginning.
	 * The lexing process starts with this entry point, receiving the text and its
	 * @param buf Text to parse for tokens.
	 * @param start The starting position of the text. Usually 0, but can be larger if only a fragment of text is processed.
	 * @param end Ending position of the text. Usually text.length, but can be smaller if only a fragment is used.
	 * @param initialState ?
	 */
	@Override
	public void reset(CharSequence buf, int start, int end, int initialState) {
		this._currentIndex = start;
		this._textLength = end;
		this._text = buf;
	}


	/**
	 * Unused?
	 * @param state
	 */
	@Override
	public void yybegin(int state) {
	}

	/**
	 * Unused?
	 * @return
	 */
	@Override
	public int yystate() {
		return 0;
	}

}
