/* The following code was generated by JFlex 1.4.3 on 15.16.10 13:53 */

package lv.modo.livescriptbrains.psi;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.impl.source.tree.ElementType;
import com.intellij.psi.tree.IElementType;
import lv.modo.livescriptbrains.psi.lexer.LexerLine;

import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Lexer is the first step of the parsing process â€” it creates semantic "tokens" from a piece of plain text.
 * A token represents a context-less, atomic, smallest piece of the programming language,
 * which will later be combined with others into semantic structures by a parser.
 * For example, the letters "i" and "f" one after another (if they are not part of another word, of course)
 * must be converted into an "if" token.
 */
public class LiveScriptLexer implements FlexLexer {
	private int STATE_NORMAL = 0;
	private int STATE_INDENT = 1;


	/**
	 * Character index that the lexer is currently at.
	 */
	private int _currentIndex;

	/**
	 *
	 */
	private int _currentLineIndex;

	/**
	 * Index of the first character in the text to process
	 */
	private int _startPosition;

	/**
	 * Length of the input text [fragment].
	 */
	private int _textLength;

	/**
	 * Index of the first character in the last token.
	 */
	private int _tokenStartIndex;

	/**
	 * Index of the next character after the token (i.e., last token character index + 1)
	 */
	private int _tokenEndIndex;

	/**
	 * Are tabs used as indents, instead of spaces?
	 */
	private boolean _indentTab;

	/**
	 * How many tabs/spaces wide is one indent.
	 */
	private int _indentSize;

	/**
	 * What's the current indentation level. Keeping track of this allows lexer to
	 * distinguish between an indent and a dedent.
	 */
	private int _currentIndentLevel;

	/**
	 * Text that we're processing.
	 */
	private CharSequence _text;

	/**
	 * Contains the line of text that is currently being worked on.
	 */
	private LexerLine _line;

	private LiveScriptLexerIndentTracker _indentTracker;


	/**
	 * Must always return the position of the first character of whatever the last token returned by {@link #advance()}.
	 * @return
	 */
	@Override
	public int getTokenStart() {
		return this._tokenStartIndex;
	}

	/**
	 * Must always return the index of the last character in the last token returned by {@link #advance()}.
	 * @return
	 */
	@Override
	public int getTokenEnd() {
		return this._tokenEndIndex;
	}

	public LiveScriptLexer() {
		this._line = null;
		this._indentTracker = new LiveScriptLexerIndentTracker();
	}

	/**
	 * Read/process input until a token can be returned, then return it.
	 * <p>This is the main lexer processor method. During the parsing process, this method is called over and over, to get
	 * the tokens one after another. It must return the next token every time, or <tt>null</tt> when the end of file
	 * is reached.</p>
	 * @return
	 * @throws IOException
	 */
	@Override
	public IElementType advance() throws IOException {
		IElementType result = null;

		// We go through the input, one line at a time.
		// Each line is run through the possible token matches.
		// Whenever a token matches, the index of the search is moved beyond it,
		// and the remaining line is run through the possible token matches again.
		// Repeat this until the end of the line is reached or it matches no tokens.
		// If the line matches no tokens and there are still characters left, mark
		// all remaining characters as invalid.

		// If we are at the end of the text, we're done.
		if (this._currentIndex >= this._textLength)
			return null;

		// Make sure we have a line to work with
		if (this._line == null || this._line.IsFinished())
			getLine();

		// Match
		return this._matchLine();
	}

	private Character _getIndentChar() {
		return this._indentTab ? '\t' : ' ';
	}

	/**
	 * Takes the [remaining] line as returned by {@link #getLine()} and tries to
	 * find the first token in it.
	 * @return
	 */
	private IElementType _matchLine() {
		IElementType result = null;
		Boolean matched = true;
		Matcher matcher = null;
		int tokenLength = 0;

		// Indent size of 0 means we haven't encountered an indent yet, so whichever -- tab or space --
		// we encounter first will become the indent character, and the number of this character on first
		// encounter will determine the indent size.
		if (this._indentSize == 0 && (matcher = this._tryMatch("^(\\t+| +)")).find()) {
			this._indentTab = matcher.group(1).startsWith("\t");
			this._indentSize = matcher.group(1).length();
			//System.out.println("Indent char is [" + this._getIndentChar() + "] x " + this._indentSize);
		}

		if (this._indentSize > 0)
		{
			// Differentiating between indents and dedents is tricky.
			// In order to know if a given indent is actually dedent, we must first count all of the indents
			// in the line and compare the total to the current indentation level.
			// If the total is less than current level, every indent on this line is actually a dedent.
			// If the total is same as current level, the indents are actually treated like newlines.
			// If the total is more than current indentation level, every indent on the line is an indent.

			// First, we count all the indents in the line.
			if (!this._indentTracker.LineProcessed) {
				matcher = this._tryMatch("" + this._getIndentChar() + "{" + this._indentSize + "}");
				while (matcher.find()) {
					// If the indent isn't the first character on the line, there's no indents and we drop tracking.
					if (this._indentTracker.IndentCount == 0 && matcher.start() > 0) {
						break;
					}
					this._indentTracker.IndentCount++;
				}
				if (this._indentTracker.IndentCount < this._currentIndentLevel)
					this._indentTracker.IndentType = LiveScriptTypes.DEDENT;
				else if (this._indentTracker.IndentCount > this._currentIndentLevel)
					this._indentTracker.IndentType = LiveScriptTypes.INDENT;
				else
					this._indentTracker.IndentType = LiveScriptTypes.NEWLINE;

				this._currentIndentLevel = this._indentTracker.IndentCount;
				this._indentTracker.LineProcessed = true;
			}
			// Then, since we know that the first X characters are indents, we can just return them immediately,
			// no matching required.
			if (this._indentTracker.CurrentIndent < this._indentTracker.IndentCount) {
				tokenLength = this._indentSize;

				result = this._indentTracker.IndentType;

				this._indentTracker.CurrentIndent++;
			}
			// There is another special case - no indent after an indent on the previous line
			else if (this._indentTracker.IndentType == LiveScriptTypes.DEDENT && this._currentIndentLevel == 0) {
				tokenLength = 0;
				result = this._indentTracker.IndentType;
			}
		}

		if (result == null) {
			if (false) {

			}
			else {
				matched = false;
				result = ElementType.ERROR_ELEMENT;
				tokenLength = this._line.RemainingLength();
			}
		}

		if (tokenLength == 0 && matched)
			tokenLength = matcher.end() - matcher.start();

		this._tokenStartIndex = this._currentIndex;
		// Move the line index beyond the matched token
		this._line.Index += tokenLength;
		// Mark the token's end index
		this._tokenEndIndex = this._tokenStartIndex + tokenLength;
		// Move the current index forwards
		this._currentIndex = this._tokenEndIndex;

		return result;
	}

	private Matcher _tryMatch(String patternString) {
		Pattern pattern = Pattern.compile(patternString);
		Matcher matcher = pattern.matcher(this._line.Text);
		return matcher;
	}

	/**
	 * Gets the remaining characters from the current index to the
	 * end of the line and returns it as a single string for matching
	 * against possible tokens.
	 */
	private void getLine() {
		boolean cr = false;
		StringBuilder sb = new StringBuilder();
		for (int a = this._currentIndex; a < this._textLength; a++) {
			char c = this._text.charAt(a);
			if (!cr || c == '\n')
				sb.append(c);

			if (cr || c == '\n' || a == this._textLength - 1) {
				this._line = new LexerLine(this._currentIndex, sb.toString());
				break;
			}

			if (c == '\r') {
				cr = true;
			}
		}
		this._indentTracker = new LiveScriptLexerIndentTracker();
	}


	/**
	 * Commands the lexer to start over from the beginning.
	 * The lexing process starts with this entry point, receiving the text and its
	 * @param buf Text to parse for tokens.
	 * @param start The starting position of the text. Usually 0, but can be larger if only a fragment of text is processed.
	 * @param end Ending position of the text. Usually text.length, but can be smaller if only a fragment is used.
	 * @param initialState ?
	 */
	@Override
	public void reset(CharSequence buf, int start, int end, int initialState) {
		this._currentIndex = start;
		this._textLength = end;
		this._text = buf;
	}


	/**
	 * Unused?
	 * @param state
	 */
	@Override
	public void yybegin(int state) {
	}

	/**
	 * Unused?
	 * @return
	 */
	@Override
	public int yystate() {
		return 0;
	}

}
