/* The following code was generated by JFlex 1.4.3 on 15.16.10 13:53 */

package lv.modo.livescriptbrains.psi;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.impl.source.tree.ElementType;
import com.intellij.psi.tree.IElementType;

import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Lexer is the first step of the parsing process â€” it creates semantic "tokens" from a piece of plain text.
 * A token represents a context-less, atomic, smallest piece of the programming language,
 * which will later be combined with others into semantic structures by a parser.
 * For example, the letters "i" and "f" one after another (if they are not part of another word, of course)
 * must be converted into an "if" token.
 */
public class LiveScriptLexer implements FlexLexer {

	/**
	 * Character index that the lexer is currently at.
	 */
	private int _currentIndex;

	/**
	 * Index of the first character in the text to process
	 */
	private int _startPosition;

	/**
	 * Length of the input text [fragment].
	 */
	private int _textLength;

	/**
	 * Index of the first character in the last token.
	 */
	private int _tokenStartIndex;

	/**
	 * Index of the next character after the token (i.e., last token character index + 1)
	 */
	private int _tokenEndIndex;

	/**
	 * Has the end of the text been reached?
	 */
	private boolean _atEndOfFile;

	/**
	 * Text that we're processing.
	 */
	private CharSequence _text;

	/**
	 * Contains the line of text that is currently being worked on.
	 */
	private CharSequence _line;


	/**
	 * Must always return the position of the first character of whatever the last token returned by {@link #advance()}.
	 * @return
	 */
	@Override
	public int getTokenStart() {
		return this._tokenStartIndex;
	}

	/**
	 * Must always return the index of the last character in the last token returned by {@link #advance()}.
	 * @return
	 */
	@Override
	public int getTokenEnd() {
		return this._tokenEndIndex;
	}

	public LiveScriptLexer() {
		this._line = new StringBuilder();
	}

	/**
	 * Read/process input until a token can be returned, then return it.
	 * <p>This is the main lexer processor method. During the parsing process, this method is called over and over, to get
	 * the tokens one after another. It must return the next token every time, or <tt>null</tt> when the end of file
	 * is reached.</p>
	 * @return
	 * @throws IOException
	 */
	@Override
	public IElementType advance() throws IOException {
		IElementType result = null;

		// We go through the input, one line at a time.
		// Each line is run through the possible token matches.
		// Whenever a token matches, the index of the search is moved beyond it,
		// and the remaining line is run through the possible token matches again.
		// Repeat this until the end of the line is reached or it matches no tokens.
		// If the line matches no tokens and there are still characters left, mark
		// all remaining characters as invalid.

		if (this._currentIndex >= this._textLength)
			return null;

		// Make sure we have a line to work with
		if (this._line == null)
			getLine();

		// Match
		Pattern pattern = Pattern.compile("^module");
		Matcher matcher = pattern.matcher(this._line);
		if (matcher.find()) {
			this._tokenStartIndex = this._currentIndex;
			this._tokenEndIndex = this._currentIndex + matcher.end();
			result = LiveScriptTypes.KEYWORD;
			this._currentIndex += matcher.end();
			this._line = null;
		}
		else {
			this._tokenStartIndex = this._currentIndex;
			this._tokenEndIndex = this._tokenStartIndex + this._line.length();
			result = ElementType.ERROR_ELEMENT;
			this._currentIndex = this._tokenEndIndex;
			this._line = null;
		}

		return result;
	}

	/**
	 * Gets the remaining characters from the current index to the
	 * end of the line and returns it as a single string for matching
	 * against possible tokens.
	 */
	private void getLine() {
		boolean cr = false;
		StringBuilder sb = new StringBuilder();
		for (int a = this._currentIndex; a < this._textLength; a++) {
			char c = this._text.charAt(a);
			if (!cr || c == '\n')
				sb.append(c);

			if (cr || c == '\n' || a == this._textLength - 1) {
				this._line = sb.toString();
				break;
			}

			if (c == '\r') {
				cr = true;
			}
		}
	}


	/**
	 * Commands the lexer to start over from the beginning.
	 * The lexing process starts with this entry point, receiving the text and its
	 * @param buf Text to parse for tokens.
	 * @param start The starting position of the text. Usually 0, but can be larger if only a fragment of text is processed.
	 * @param end Ending position of the text. Usually text.length, but can be smaller if only a fragment is used.
	 * @param initialState ?
	 */
	@Override
	public void reset(CharSequence buf, int start, int end, int initialState) {
		this._currentIndex = start;
		this._textLength = end;
		this._atEndOfFile = false;
		this._text = buf;
	}


	/**
	 * Unused?
	 * @param state
	 */
	@Override
	public void yybegin(int state) {
	}

	/**
	 * Unused?
	 * @return
	 */
	@Override
	public int yystate() {
		return 0;
	}

}
