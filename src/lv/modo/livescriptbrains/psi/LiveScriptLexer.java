/* The following code was generated by JFlex 1.4.3 on 15.16.10 13:53 */

package lv.modo.livescriptbrains.psi;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.impl.source.tree.ElementType;
import com.intellij.psi.tree.IElementType;
import lv.modo.livescriptbrains.psi.lexer.LexerLine;

import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Lexer is the first step of the parsing process â€” it creates semantic "tokens" from a piece of plain text.
 * A token represents a context-less, atomic, smallest piece of the programming language,
 * which will later be combined with others into semantic structures by a parser.
 * For example, the letters "i" and "f" one after another (if they are not part of another word, of course)
 * must be converted into an "if" token.
 */
public class LiveScriptLexer implements FlexLexer {
	private int STATE_NORMAL = 0;
	private int STATE_INDENT = 1;


	/**
	 * Character index that the lexer is currently at.
	 */
	private int _currentIndex;

	/**
	 *
	 */
	private int _currentLineIndex;

	/**
	 * Index of the first character in the text to process
	 */
	private int _startPosition;

	/**
	 * Length of the input text [fragment].
	 */
	private int _textLength;

	/**
	 * Index of the first character in the last token.
	 */
	private int _tokenStartIndex;

	/**
	 * Index of the next character after the token (i.e., last token character index + 1)
	 */
	private int _tokenEndIndex;

	/**
	 * Are tabs used as indents, instead of spaces?
	 */
	private boolean _indentTab;

	/**
	 * How many tabs/spaces wide is one indent.
	 */
	private int _indentSize;

	/**
	 * What's the current indentation level. Keeping track of this allows lexer to
	 * distinguish between an indent and a dedent.
	 */
	private int _currentIndentLevel;

	/**
	 * Text that we're processing.
	 */
	private CharSequence _text;

	/**
	 * Contains the line of text that is currently being worked on.
	 */
	private LexerLine _line;

	/**
	 * Must always return the position of the first character of whatever the last token returned by {@link #advance()}.
	 * @return
	 */
	@Override
	public int getTokenStart() {
		return this._tokenStartIndex;
	}

	/**
	 * Must always return the index of the last character in the last token returned by {@link #advance()}.
	 * @return
	 */
	@Override
	public int getTokenEnd() {
		return this._tokenEndIndex;
	}

	public LiveScriptLexer() {
		this._line = null;
	}

	/**
	 * Read/process input until a token can be returned, then return it.
	 * <p>This is the main lexer processor method. During the parsing process, this method is called over and over, to get
	 * the tokens one after another. It must return the next token every time, or <tt>null</tt> when the end of file
	 * is reached.</p>
	 * @return
	 * @throws IOException
	 */
	@Override
	public IElementType advance() throws IOException {
		IElementType result = null;

		// We go through the input, one line at a time.
		// Each line is run through the possible token matches.
		// Whenever a token matches, the index of the search is moved beyond it,
		// and the remaining line is run through the possible token matches again.
		// Repeat this until the end of the line is reached or it matches no tokens.
		// If the line matches no tokens and there are still characters left, mark
		// all remaining characters as invalid.

		// If we are at the end of the text, we're done.
		if (this._currentIndex >= this._textLength)
			return null;

		// Make sure we have a line to work with
		if (this._line == null || this._line.IsFinished())
			getLine();

		// Match
		return this._matchLine();
	}

	private Character _getIndentChar() {
		return this._indentTab ? '\t' : ' ';
	}

	/**
	 * Takes the [remaining] line as returned by {@link #getLine()} and tries to
	 * find the first token in it.
	 * @return
	 */
	private IElementType _matchLine() {
		IElementType result = null;
		Boolean matched = true;
		Matcher matcher = null;
		int tokenLength = 0;

		// Indent size of 0 means we haven't encountered an indent yet, so whichever -- tab or space --
		// we encounter first will become the indent character, and the number of this character on first
		// encounter will determine the indent size.
		if (this._indentSize == 0 && (matcher = this._tryMatch("^(\\t+| +)", true)).find()) {
			this._indentTab = matcher.group(1).startsWith("\t");
			this._indentSize = matcher.group(1).length();
			//System.out.println("Indent char is [" + this._getIndentChar() + "] x " + this._indentSize);
		}

		// Once we know what an indent is, we can check for it.
		if (this._indentSize > 0
				&& (matcher = this._tryMatch("^" + this._getIndentChar() + "{" + this._indentSize + "}", true))
					.find(this._line.Index))
		{
			result = LiveScriptTypes.INDENT;
		}

		// "class" keyword
		if (result == null && (matcher = this._tryMatch("^(class)\\s+")).find()) {
			tokenLength = matcher.group(1).length();
			result = LiveScriptTypes.CLASS;
		}

		// whitespace
		if (result == null && (matcher = this._tryMatch("^\\s+")).find()) {
			result = ElementType.WHITE_SPACE;
		}


		if (result == null) {
			if (false) {

			}
			else {
				matched = false;
				result = ElementType.BAD_CHARACTER;
				tokenLength = 1;
			}
		}

		if (tokenLength == 0 && matched)
			tokenLength = matcher.end() - matcher.start();

		this._tokenStartIndex = this._currentIndex;
		// Move the line index beyond the matched token
		this._line.Index += tokenLength;
		// Mark the token's end index
		this._tokenEndIndex = this._tokenStartIndex + tokenLength;
		// Move the current index forwards
		this._currentIndex = this._tokenEndIndex;

		return result;
	}

	private Matcher _tryMatch(String patternString, boolean fullLine) {
		Pattern pattern = Pattern.compile(patternString);
		Matcher matcher = pattern.matcher(fullLine ? this._line.Text : this._line.RemainingText());
		return matcher;
	}

	private Matcher _tryMatch(String patternString) {
		return this._tryMatch(patternString, false);
	}

	/**
	 * Gets the remaining characters from the current index to the
	 * end of the line and returns it as a single string for matching
	 * against possible tokens.
	 */
	private void getLine() {
		boolean cr = false;
		StringBuilder sb = new StringBuilder();
		for (int a = this._currentIndex; a < this._textLength; a++) {
			char c = this._text.charAt(a);
			if (!cr || c == '\n')
				sb.append(c);

			if (cr || c == '\n' || a == this._textLength - 1) {
				this._line = new LexerLine(this._currentIndex, sb.toString());
				break;
			}

			if (c == '\r') {
				cr = true;
			}
		}
	}


	/**
	 * Commands the lexer to start over from the beginning.
	 * The lexing process starts with this entry point, receiving the text and its
	 * @param buf Text to parse for tokens.
	 * @param start The starting position of the text. Usually 0, but can be larger if only a fragment of text is processed.
	 * @param end Ending position of the text. Usually text.length, but can be smaller if only a fragment is used.
	 * @param initialState ?
	 */
	@Override
	public void reset(CharSequence buf, int start, int end, int initialState) {
		this._currentIndex = start;
		this._textLength = end;
		this._text = buf;
	}


	/**
	 * Unused?
	 * @param state
	 */
	@Override
	public void yybegin(int state) {
	}

	/**
	 * Unused?
	 * @return
	 */
	@Override
	public int yystate() {
		return 0;
	}

}
