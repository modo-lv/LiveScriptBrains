{
  parserClass="com.simpleplugin.parser.LiveScriptParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="LiveScript"
  psiImplClassSuffix="Impl"
  psiPackage="com.simpleplugin.psi"
  psiImplPackage="com.simpleplugin.psi.impl"

  elementTypeHolderClass="com.simpleplugin.psi.LiveScriptTypes"
  elementTypeClass="com.simpleplugin.psi.LiveScriptElementType"
  tokenTypeClass="com.simpleplugin.psi.LiveScriptTokenType"

  parserUtilClass="com.simpleplugin.psi.LiveScriptParserUtil"

  extends(".*Expression$")=Expression

  recoverWhile("Statement")="recover"
}

file ::= (Statement | Comment | NEWLINE)*
private recover ::= !NEWLINE

Comment ::= COMMENT_LINE

Statement ::= IStringStatement | OperationOrValue

IStringStatement ::= STRING (STRING? (IDENTIFIER|ISTRING OperationOrValue ISTRING))+ STRING

OperationOrValue ::= Operation | Value

Operation ::= AssignOperation | MathOperation

AssignOperation ::= IDENTIFIER ASSIGN (OperationOrValue) {pin=2 rightAssociative=true}

MathOperation ::= Value MATH_OP OperationOrValue {pin=2}

// ::= ASSIGN

// ::= MATH_OP

Value ::= Literal | IDENTIFIER

Literal ::= BOOLEAN | NUMBER | EMPTY | STRING

// ::= BOOLEAN

private AnyString ::= STRING | ISTRING

// ::= ISTRING

// ::= STRING

// ::= NUMBER

// ::= EMPTY

// ::= IDENTIFIER

// ::= COMMENT_LINE

// ::= NEWLINE



/*
oldFile ::= (Statement | Com | NEWLINE)* <<eof>>

external objDef ::= objDef

private recover_statement ::= !NEWLINE
private recover_inter ::= !(NEWLINE | STRING_INTER_END)

Statement ::= <<optionalParens Expression>> {recoverWhile="recover_statement"}

Expression ::= TestExpression
    | AssignOpExpression
    | OpExpression
    | RegexExpression
    | LiteralExpression
    | ReferenceExpression
    | CurlObjDefExpression
    | ObjDefExpression
    | ListExpression
    | ImplicitListExpression

InterLines ::= <<optionalParens Expression>>* {recoverWhile="recover_inter"}

// Lists
ListExpression ::= BRACK_L <<multiLineArgList ValueExpression>> BRACK_R

ImplicitListExpression ::= Assign INDENT Expression Expression+ DEDENT

// Regex
RegexExpression ::= REGEX (COMMENT_LINE | REGEX)*;

CurlObjDefExpression ::= CURL_L (<<multiLineArgList (ExplicitPropDefExpression | ImplicitPropDefExpression)>>)* CURL_R

ObjDefExpression ::= <<multiLineArgList ExplicitPropDefExpression>>

ExplicitPropDefExpression ::= (ValueExpression COLON Expression) {rightAssociative=true}

ImplicitPropDefExpression ::= (("+"|"-")? ValueExpression)

// Operations
private Assign ::= ReferenceExpression EQ NEWLINE?

AssignOpExpression ::= Assign Expression

OpExpression ::= Expression OPERATOR NEWLINE? Expression


// Literal and value expressions

ValueExpression ::= <<optionalParens (ReferenceExpression | LiteralExpression)>>

LiteralExpression ::= RESERVED_LITERAL | ReferenceExpression | NUMBER | InterpolatedStringExpression | StringExpression

ReferenceExpression ::= PropReference | VarReference

private VarReference ::= IDENTIFIER | THIS | THIS_AT

private PropReference ::= (THIS_AT + IDENTIFIER (DOT IDENTIFIER)*) | ((IDENTIFIER|THIS) (DOT IDENTIFIER)+)


// Strings

StringExpression ::= STRING_START string STRING_END | BACKSTRING | HEREDOC


InterStringExpression ::= STRING_START string STRING_INTER_START
    | STRING_INTER_END string STRING_INTER_START
    | STRING_INTER_END string STRING_END

InterpolatedStringExpression ::= InterStringExpression+ InterLines InterStringExpression+

TestExpression ::= TEST

// Pieces
private meta optionalParens ::= PAREN_L <<param>> PAREN_R | <<param>>
private meta inlineArgList ::= <<param>> (InlineSeparator <<param>>)*
private meta multiLineArgList ::= <<param>> (AnySeparator <<param>>)* {rightAssociative=true}
private meta indented ::= INDENT <<param>>+ DEDENT?
Com ::= COMMENT_LINE | COMMENT_BLOCK
InlineSeparator::= COMMA?
MultilineSeparator ::= COMMA? NEWLINE+
AnySeparator::= MultilineSeparator | InlineSeparator
private string ::= STRING* (IDENTIFIER | STRING)* */
